/*
	JS一直没有模块(module)体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。
	其他语言都有这项功能，如Ruby的require、Python的import，甚至CSS都有@import，
	但是JS任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍

	模块化简单来说就是指:
		将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来

	在ES6之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。
	前者用于服务器，后者用于浏览器。
	ES6在语言标准的层面上，实现了模块功能，而且实现得相当简单，
	完全可以取代CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。

	ES6模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。
	CommonJS和AMD模块，都只能在运行时确定这些东西。
	比如，CommonJS模块就是对象，输入时必须查找对象属性

	ES6模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入

	由于ES6模块是编译时加载，使得静态分析成为可能。
	能进一步拓宽JS的语法，如引入宏(macro)和类型检验(type system)这些只能靠静态分析实现的功能

	除了静态加载带来的各种好处，ES6模块还有以下好处:
		1.不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。
		  目前，通过各种工具库，其实已经做到了这一点。
		2.将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。
		3.不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供
		4.可以有效防止命名冲突
		5.每个模块的代码都是可复用的
		6.提高整体代码可维护性
*/
// CommonJS模块
let { stat, readfile } = require("fs");
/* 
	实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取2个方法。
	这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”
*/
// 等同于
let _fs = require("fs");

stat = _fs.stat;
readfile = _fs.readfile;

// ES6模块
/* 
	从fs模块加载2个方法，其他方法不加载。
	这种加载称为"编译时加载"或者静态加载，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。
	但这也导致了没法引用ES6模块本身，因为它不是对象
*/
import {stat, readfile} from 'fs';